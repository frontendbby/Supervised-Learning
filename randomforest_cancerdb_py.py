# -*- coding: utf-8 -*-
"""RandomForest- CancerDB.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AnIASwXV-mG7l7i3odrxS42Yr-5aAibd
"""

from sklearn import datasets

dataset = datasets.load_breast_cancer()
print(dataset)

from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score

import pandas as pd
from sklearn.datasets import load_breast_cancer

# 1. Cargar el dataset
cancer = load_breast_cancer()

# 2. Crear un DataFrame de pandas con los datos y nombres de columnas
df = pd.DataFrame(data=cancer.data, columns=cancer.feature_names)

# 3. Agregar la columna objetivo (target)
df['target'] = cancer.target

# 4. Mostrar las primeras filas
#print(df.head())
df.head

# Para ver la descripción general
#print(df.info())

print("Información en el Dataset: ")
print(dataset.keys())
print

#print("Características del Dataset: ")
#print(dataset.DESCR())

X = dataset.data
y = dataset.target

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.tree import DecisionTreeClassifier # Added this import

#Separación de los datos
X_train, X_test, y_train, y_test = train_test_split (X, y, test_size=0.2)

#Se escalan los datos
#from sklearn.preprocessing import StandardScaler
escalar = StandardScaler()
X_train = escalar.fit_transform(X_train)
X_test = escalar.transform(X_test)

#Se define el algoritmo a utilizar
algoritmo = RandomForestClassifier(n_estimators=10)

#Entrenamos el modelo
algoritmo.fit(X_train, y_train);

#Se realiza la predicción
y_pred = algoritmo.predict(X_test)

#Se realiza la probabilidad
y_proba = algoritmo.predict_proba(X_test)[:, 1]

#Se verifica con la matriz de confusión
from sklearn.metrics import confusion_matrix
matriz = confusion_matrix(y_test, y_pred)
print("Matriz de confusión: ")
print(matriz)

#Se calcula la precisión del modelo
from sklearn.metrics import precision_score

precision = precision_score(y_test,y_pred)
print("Precisión del Modelo: ")
print(precision)

#Calculamos la exactitud del modelo
from sklearn.metrics import accuracy_score

exactitud = accuracy_score(y_test,y_pred)
print("Exactitud del Modelo: ")
print(exactitud)

#Calculamos la sensibilidad del modelo
from sklearn.metrics import recall_score

sensibilidad = recall_score(y_test,y_pred)
print("Sensibilidad del Modelo: ")
print(sensibilidad)

#Calculamos el puntaje F1 del modelo
from sklearn.metrics import f1_score

puntajeF1 = f1_score(y_test,y_pred)
print("Puntaje F1 del Modelo: ")
print(puntajeF1)

#Calculamos la curva ROC-AUC del modelo
from sklearn.metrics import roc_auc_score

#roc_auc = roc_auc_score(y_test,y_pred)
roc_auc = roc_auc_score(y_test, y_proba)
print("Curva ROC - AUC del Modelo: ")
print(roc_auc)

#print("Precisión del Modelo: ", precision)
#print("Exactitud del Modelo: ",exactitud)
#print("Sensibilidad del Modelo: ",sensibilidad)
#print("Puntaje F1 del Modelo: ", puntajeF1)
#print("Curva ROC - AUC del Modelo: ", roc_auc)

import matplotlib.pyplot as plt
from sklearn.tree import plot_tree

# Extraer un estimador (árbol de decisión) del RandomForestClassifier
# Random Forest es un conjunto de árboles de decisión, por lo que visualizaremos uno de ellos.
one_tree = algoritmo.estimators_[0]

plt.figure(figsize=(20,15))
plot_tree(one_tree,
          feature_names=dataset.feature_names,  # Usar los nombres de las características del dataset original
          class_names=dataset.target_names,    # Usar los nombres de las clases del dataset original
          filled=True,
          rounded=True,
          fontsize=8)
plt.title("Visualización de un Árbol de Decisión del Bosque Aleatorio")
plt.show()

import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, auc

# 1. Obtener probabilidades de la clase positiva ***PUEDE OMITIRSE PORQUE SE OBTUVO PREVIAMENTE***
#y_proba = algoritmo.predict_proba(X_test)[:, 1]

# 2. Calcular FPR, TPR y umbrales
fpr, tpr, thresholds = roc_curve(y_test, y_proba)

# 3. Calcular el área bajo la curva (AUC)
roc_auc = auc(fpr, tpr)

# 4. Graficar
plt.figure()
plt.plot(fpr, tpr, label=f"Curva ROC (AUC = {roc_auc:.3f})")
plt.plot([0, 1], [0, 1], linestyle="--", label="Clasificador aleatorio")

plt.xlabel("Tasa de Falsos Positivos (FPR)")
plt.ylabel("Tasa de Verdaderos Positivos (TPR)")
plt.title("Curva ROC - Regresión Logística")
plt.legend(loc="lower right")
plt.grid(True)
plt.show()